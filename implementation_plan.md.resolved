# 屏幕监控 UI 功能实现计划

实现锁机/解锁功能按钮和优化鼠标坐标映射，确保在屏幕监控区域的鼠标操作能正确反映到被控端。

## 现有代码分析

### 已有实现
1. **锁机命令协议**: `CMD_LOCK_MACHINE = 9`, `CMD_UNLOCK_MACHINE = 10` 已在 [PacketProtocol.h](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/include/Protocol/Infra/PacketProtocol.h) 定义
2. **侧边栏按钮**: [OnSidebarLockScreen()](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/view/MonitorViewDlg.cpp#782-792) 已创建，但只有 TODO 注释
3. **鼠标坐标转换**: [WindowToRemote()](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/view/MonitorViewDlg.cpp#438-458) 方法已实现基本逻辑
4. **鼠标事件发送**: `IOModel::injectMouse()` 通过 [MouseEventData](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/Enities.h#74-120) 序列化发送

### 需要修改
1. 添加锁机/解锁的 Controller 接口和实现
2. 完善 [OnSidebarLockScreen()](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/view/MonitorViewDlg.cpp#782-792) 实际调用逻辑
3. 优化坐标转换确保边界正确处理

---

## Proposed Changes

### Component 1: 接口层

#### [MODIFY] [IController.h](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/interfaces/IController.h)
在 [IMonitorController](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/interfaces/IController.h#66-116) 类中添加锁机控制方法：
```cpp
// 锁定/解锁远程屏幕
virtual void OnLockScreen() = 0;
virtual void OnUnlockScreen() = 0;
```

#### [MODIFY] [Interface.h](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/model/Interface.h)
在 [IIoModel](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/model/Interface.h#134-142) 类中添加锁机命令方法:
```cpp
// 发送锁机/解锁命令
virtual void sendLockCommand(bool lock) = 0;
```

---

### Component 2: Model 层

#### [MODIFY] [IOModel.h](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/model/IOModel.h)
添加方法声明:
```cpp
void sendLockCommand(bool lock) override;
```

#### [MODIFY] [IOModel.cpp](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/model/IOModel.cpp)
实现发送锁机/解锁命令:
```cpp
void IOModel::sendLockCommand(bool lock) {
    if (!net_) return;
    Packet pkt;
    pkt.sCmd = static_cast<WORD>(lock ? CMD_LOCK_MACHINE : CMD_UNLOCK_MACHINE);
    pkt.data.clear(); // 无需额外数据
    net_->sendPacket(pkt);
}
```

---

### Component 3: Controller 层

#### [MODIFY] [MonitorController.h](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/controller/MonitorController.h)
添加方法声明:
```cpp
void OnLockScreen() override;
void OnUnlockScreen() override;
```

#### [MODIFY] [MonitorController.cpp](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/controller/MonitorController.cpp)
实现锁机/解锁调用:
```cpp
void MonitorController::OnLockScreen() { 
    if (io_) io_->sendLockCommand(true); 
}

void MonitorController::OnUnlockScreen() { 
    if (io_) io_->sendLockCommand(false); 
}
```

---

### Component 4: View 层

#### [MODIFY] [MonitorViewDlg.cpp](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/view/MonitorViewDlg.cpp)

**修改 [OnSidebarLockScreen()](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/view/MonitorViewDlg.cpp#782-792) 方法**:
```cpp
void MonitorViewDlg::OnSidebarLockScreen() {
    m_bScreenLocked = !m_bScreenLocked;

    if (controller_) {
        if (m_bScreenLocked) {
            controller_->OnLockScreen();
        } else {
            controller_->OnUnlockScreen();
        }
    }

    m_btnSidebarLock.SetWindowText(m_bScreenLocked ? _T("解锁屏幕") : _T("锁定屏幕"));
    UpdateStatusBar(m_bScreenLocked ? "远程屏幕已锁定" : "远程屏幕已解锁", 0);
}
```

**优化 [WindowToRemote()](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/view/MonitorViewDlg.cpp#438-458) 坐标转换**:

当前实现已经处理了基本的坐标转换，但需要增强以下方面：
1. 检测鼠标是否在有效画布区域内
2. 处理窗口最小化或帧未加载时的边界情况

```cpp
CPoint MonitorViewDlg::WindowToRemote(CPoint pt) {
    // 检查帧数据和画布有效性
    if (!m_currentFrame || m_frameRect.IsRectEmpty())
        return CPoint(-1, -1);  // 返回无效坐标

    // 检查点击位置是否在画布区域内
    if (!m_frameRect.PtInRect(pt))
        return CPoint(-1, -1);  // 返回无效坐标表示点击在画布外

    int frameW = m_frameRect.Width();
    int frameH = m_frameRect.Height();
    if (frameW <= 0 || frameH <= 0)
        return CPoint(-1, -1);

    // 计算缩放比例
    float scaleX = (float)m_currentFrame->width / frameW;
    float scaleY = (float)m_currentFrame->height / frameH;

    // 转换坐标
    int remoteX = (int)((pt.x - m_frameRect.left) * scaleX);
    int remoteY = (int)((pt.y - m_frameRect.top) * scaleY);

    // 边界检查 - 确保坐标在有效范围内
    remoteX = std::clamp(remoteX, 0, (int)m_currentFrame->width - 1);
    remoteY = std::clamp(remoteY, 0, (int)m_currentFrame->height - 1);

    return CPoint(remoteX, remoteY);
}
```

**修改鼠标事件处理以检查有效坐标**:

需要修改各鼠标事件处理函数，检查返回的坐标是否有效：
```cpp
void MonitorViewDlg::OnMouseMove(UINT nFlags, CPoint point) {
    if (controller_ && m_bMouseControlEnabled) {
        CPoint remote = WindowToRemote(point);
        if (remote.x >= 0 && remote.y >= 0) {  // 只有有效坐标才发送
            controller_->OnMouseMove(remote.x, remote.y);
        }
    }
    CDialogEx::OnMouseMove(nFlags, point);
}
```

---

## Verification Plan

### 编译测试
1. 在 Visual Studio 中打开解决方案 `RemoteControl.sln`
2. 重新生成 `RemoteControl_Client` 项目
3. 确认无编译错误

### 手动功能验证

#### 验证锁机/解锁功能
1. 启动服务端程序 (`RemoteControl_Server`)
2. 启动客户端程序 (`RemoteControl_Client`)
3. 连接到服务端
4. 点击"开始监视"按钮打开监控窗口
5. 在监控窗口侧边栏点击"锁定屏幕"按钮
6. 观察：
   - 按钮文字变为"解锁屏幕"
   - 状态栏显示"远程屏幕已锁定"
   - 服务端控制台输出锁机相关日志
7. 再次点击"解锁屏幕"按钮
8. 观察：
   - 按钮文字恢复为"锁定屏幕"
   - 状态栏显示"远程屏幕已解锁"
   - 服务端控制台输出解锁相关日志

#### 验证鼠标坐标映射  
1. 在监控窗口中启用"鼠标操作"（点击侧边栏按钮）
2. 在监控画面区域移动鼠标
3. 观察服务端鼠标是否跟随正确移动
4. 测试画布边缘的鼠标操作，确认不会发送无效坐标
5. 调整窗口大小后重复测试，确认坐标仍然正确

> [!IMPORTANT]
> 由于这是 MFC Windows 桌面应用，需要用户手动编译和测试。测试需要同时运行服务端和客户端程序。
