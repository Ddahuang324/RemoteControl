# VIEW层解耦重构实现计划

本文档详细说明如何重构VIEW层，使其 **只通过IController接口与Controller层交互**，消除对Model层的直接依赖。

---

## 问题背景

### 当前架构问题

```mermaid
graph LR
    subgraph 当前架构-有耦合
        V[View] --> C[IController]
        V --> M[IModel]
        C --> M
    end
```

| 文件 | 问题 | 详情 |
|------|------|------|
| [RemoteControlViewDlg.h](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/view/RemoteControlViewDlg.h) | 持有Model引用 | `network_`, `fileSystem_` 成员变量 |
| [MonitorViewDlg.h](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/view/MonitorViewDlg.h) | 持有Model引用 | `monitor_`, `io_` 成员变量 |
| [RemoteControlViewDlg.cpp:1077](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/view/RemoteControlViewDlg.cpp#L1077) | 直接调用Model | `fileSystem_->listDirectory()` |

### 目标架构

```mermaid
graph LR
    subgraph 目标架构-解耦
        V2[View] --> C2[IController]
        C2 --> M2[IModel]
        C2 -.->|回调更新| V2
    end
```

---

## 用户审核事项

> [!IMPORTANT]
> **构造函数签名变更**：[RemoteControlViewDlg](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/view/RemoteControlViewDlg.cpp#17-32) 和 [MonitorViewDlg](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/view/MonitorViewDlg.h#19-166) 构造函数将移除Model参数，可能影响测试代码或其他创建View的位置。

> [!WARNING]
> **接口扩展**：需要在 [IMainController](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/controller/IController.h#18-61) 添加新方法来处理树节点展开时的子目录加载，这是一个**接口变更**。

---

## 变更方案

### 组件1: Controller接口扩展

#### [MODIFY] [IController.h](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/controller/IController.h)

**新增方法** 到 [IMainController](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/controller/IController.h#18-61) 接口：

```diff
class IMainController {
public:
  // ... existing methods ...

+ // 树节点展开时加载子目录（View层需要提供HTREEITEM句柄以便后续回调更新）
+ virtual void OnTreeNodeExpanding(void* hTreeItem, const std::string& path) = 0;
};
```

---

### 组件2: Controller实现更新

#### [MODIFY] [MainController.h](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/controller/MainController.h)

```diff
class MainController : public IMainController {
public:
  // ... existing methods ...
  
+ void OnTreeNodeExpanding(void* hTreeItem, const std::string& path) override;
};
```

#### [MODIFY] [MainController.cpp](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/controller/MainController.cpp)

实现新方法，将 [OnTreeItemExpanding](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/view/RemoteControlViewDlg.cpp#1021-1100) 中对 `fileSystem_->listDirectory()` 的调用移至Controller：

```cpp
void MainController::OnTreeNodeExpanding(void* hTreeItem, const std::string& path) {
    HTREEITEM hItem = static_cast<HTREEITEM>(hTreeItem);
    HWND hWnd = m_protocol->view->GetSafeHwnd();
    
    auto isFirst = std::make_shared<bool>(true);
    m_protocol->fileSystem->listDirectory(
        path,
        [hWnd, hItem, isFirst](const std::vector<FileSystemProtocol::FileEntry>& entries, bool hasMore) {
            if (!::IsWindow(hWnd)) return;
            
            auto* pData = new SubDirUpdateData();
            pData->hParent = hItem;
            pData->entries = entries;
            pData->isFirst = *isFirst;
            *isFirst = false;
            
            ::PostMessage(hWnd, WM_UPDATE_SUB_DIRS, (WPARAM)pData, 0);
        });
}
```

---

### 组件3: View层重构 — RemoteControlViewDlg

#### [MODIFY] [RemoteControlViewDlg.h](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/view/RemoteControlViewDlg.h)

```diff
class RemoteControlViewDlg : public CDialogEx {
public:
- explicit RemoteControlViewDlg(std::shared_ptr<INetworkModel> network,
-                               std::shared_ptr<IFileSystemModel> fileSystem,
-                               CWnd *pParent = nullptr);
+ explicit RemoteControlViewDlg(CWnd *pParent = nullptr);

private:
- // ---- Model接口 ----
- std::shared_ptr<INetworkModel> network_;
- std::shared_ptr<IFileSystemModel> fileSystem_;

  // ---- Controller ----
  std::shared_ptr<IMainController> controller_;
};
```

> [!NOTE]
> 移除 `#include "../model/Interface.h"`，改为只包含必要的数据类型定义。

#### [MODIFY] [RemoteControlViewDlg.cpp](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/view/RemoteControlViewDlg.cpp)

**变更1**: 修改构造函数
```diff
- RemoteControlViewDlg::RemoteControlViewDlg(std::shared_ptr<INetworkModel> network,
-                                            std::shared_ptr<IFileSystemModel> fileSystem,
-                                            CWnd *pParent)
-     : CDialogEx(IDD_MVC_MAIN_DIALOG, pParent),
-       network_(network), fileSystem_(fileSystem) {
+ RemoteControlViewDlg::RemoteControlViewDlg(CWnd *pParent)
+     : CDialogEx(IDD_MVC_MAIN_DIALOG, pParent) {
```

**变更2**: 修改 [OnTreeItemExpanding](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/view/RemoteControlViewDlg.cpp#1021-1100) (第1020-1098行)

移除直接调用Model的代码，改为委托给Controller：

```diff
void RemoteControlViewDlg::OnTreeItemExpanding(NMHDR *pNMHDR, LRESULT *pResult) {
    // ... validation code ...
    
-   if (!fileSystem_) {
+   if (!controller_) {
        TRACE(_T("  Error: controller_ is null\n"));
        return;
    }
    
    CT2A convPath(path);
    std::string pathStr(static_cast<const char *>(convPath));
-   HWND hWnd = GetSafeHwnd();
-   
-   auto isFirst = std::make_shared<bool>(true);
-   fileSystem_->listDirectory(
-       pathStr, [hWnd, hItem, pathStr, isFirst](...) { ... });
+   
+   // 委托给Controller处理
+   controller_->OnTreeNodeExpanding(static_cast<void*>(hItem), pathStr);
}
```

---

### 组件4: View层重构 — MonitorViewDlg

#### [MODIFY] [MonitorViewDlg.h](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/view/MonitorViewDlg.h)

```diff
class MonitorViewDlg : public CDialogEx {
public:
- explicit MonitorViewDlg(std::shared_ptr<IMonitorModel> monitor,
-                         std::shared_ptr<IIoModel> io,
-                         CWnd *pParent = nullptr);
+ explicit MonitorViewDlg(CWnd *pParent = nullptr);

private:
- // ---- Model接口 ----
- std::shared_ptr<IMonitorModel> monitor_;
- std::shared_ptr<IIoModel> io_;

  // ---- Controller ----
  std::shared_ptr<IMonitorController> controller_;
};
```

#### [MODIFY] [MonitorViewDlg.cpp](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/mvc/view/MonitorViewDlg.cpp)

修改构造函数，移除Model初始化。

---

### 组件5: 应用入口更新

#### [MODIFY] [RemoteControl_Client.cpp](file:///d:/编程/项目/RemoteControl/RemoteControl_Client/RemoteControl_Client.cpp)

```diff
  // 4. Create View
- RemoteControlViewDlg dlg(network, fileSystem);
+ RemoteControlViewDlg dlg;
  m_pMainWnd = &dlg;

  // 5. Create Controller
  auto controller =
      std::make_shared<MainController>(network, fileSystem, monitor, io, &dlg);

  // 6. Inject Controller into View
  dlg.SetController(controller);
```

---

## 验证计划

### 编译测试

```powershell
# 在 Visual Studio Developer Command Prompt 中执行
cd d:\编程\项目\RemoteControl
msbuild RemoteControl.sln /p:Configuration=Debug /p:Platform=x64 /t:Rebuild
```

**预期结果**: 编译成功，无错误。

### 手动功能验证

由于这是MFC桌面应用，需要手动验证：

1. **启动客户端应用程序**
2. **测试连接功能**: 输入IP和端口，点击"连接"按钮
3. **测试文件浏览**: 
   - 确认驱动器列表正常显示
   - 点击展开驱动器节点，确认子目录正常加载
   - 选择目录后右侧文件列表正常显示
4. **测试监视功能**: 点击"屏幕监视"按钮，确认监视窗口正常打开

> [!TIP]
> 如果您有特定的测试脚本或自动化测试框架，请告知，我可以调整验证计划。

---

## 重构前后对比

| 指标 | 重构前 | 重构后 |
|------|--------|--------|
| View持有的Model引用 | 4个 | 0个 |
| View直接调用Model | 1处 | 0处 |
| View头文件包含Model接口 | ✗ | ✓ 移除 |
| Controller接口方法 | 11个 | 12个 (+1) |

---

## 文件变更摘要

| 文件 | 操作 | 影响范围 |
|------|------|----------|
| [IController.h](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/mvc/controller/IController.h) | 新增方法 | 接口变更 |
| `MainController.h/cpp` | 实现新方法 | 内部实现 |
| `RemoteControlViewDlg.h/cpp` | 移除Model依赖 | 构造函数签名变更 |
| `MonitorViewDlg.h/cpp` | 移除Model依赖 | 构造函数签名变更 |
| [RemoteControl_Client.cpp](file:///d:/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/RemoteControl/RemoteControl_Client/RemoteControl_Client.cpp) | 更新View创建 | 初始化流程 |
